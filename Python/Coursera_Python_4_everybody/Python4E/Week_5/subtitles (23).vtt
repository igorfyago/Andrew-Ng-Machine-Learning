WEBVTT

1
00:00:08.902 --> 00:00:12.798
So welcome back, now we're going to build
up and talk about some slightly more

2
00:00:12.798 --> 00:00:16.800
complex conditional execution
patterns that you can build up.

3
00:00:16.800 --> 00:00:19.980
So as you do the if-then-else, again,

4
00:00:19.980 --> 00:00:24.850
one of the things to do is to visualize
the blocks, start thinking of the blocks.

5
00:00:24.850 --> 00:00:28.500
And in this case, you'd think of the block
as sort of starting at the if and

6
00:00:28.500 --> 00:00:32.870
then ending after the last indented line.

7
00:00:32.870 --> 00:00:35.560
But the if and the else kind of
are a piece of one thing and

8
00:00:35.560 --> 00:00:38.630
you can sort of think of
this as the block, right?

9
00:00:38.630 --> 00:00:41.860
And one of the things about these blocks
is they have one entrance and one exit,

10
00:00:41.860 --> 00:00:43.170
not that that's a big deal.

11
00:00:43.170 --> 00:00:46.524
But it's a good way to think about how
you mentally start drawing the blocks.

12
00:00:46.524 --> 00:00:50.350
You see one entrance and one exit,
and there's some complexity,

13
00:00:50.350 --> 00:00:53.304
there's some logic that
you're sort of building.

14
00:00:53.304 --> 00:00:55.320
And that's how these blocks work.

15
00:00:56.580 --> 00:01:02.640
So the next step up in
complexity is a multi-way if.

16
00:01:02.640 --> 00:01:07.960
And that uses a keyword called elif, which
is really a combination of else and if.

17
00:01:09.020 --> 00:01:13.890
So the way it works is, probably easier
to do this on a GPS version of it.

18
00:01:13.890 --> 00:01:17.280
Is it comes down here,
forget what's in here, it asks yes or no.

19
00:01:17.280 --> 00:01:20.420
If it's yes, it runs this one,
and then it's all done.

20
00:01:20.420 --> 00:01:24.070
If it's no and then yes,
it runs this one, and it's all done.

21
00:01:24.070 --> 00:01:26.510
And if it's no, no, no,
it runs this one and it's done.

22
00:01:26.510 --> 00:01:30.920
A key thing is it's only
going to do one of these three.

23
00:01:30.920 --> 00:01:33.990
It's not going to do two,
it's only going to do one.

24
00:01:33.990 --> 00:01:36.430
And it checks these questions in order.

25
00:01:38.250 --> 00:01:40.030
And then this else is like a catch-all.

26
00:01:42.440 --> 00:01:45.240
So let's take a look at how
this particular one works.

27
00:01:45.240 --> 00:01:48.020
It depends on the value of x.

28
00:01:48.020 --> 00:01:50.620
So let's, what if x were 0?

29
00:01:50.620 --> 00:01:54.700
Well, if x were 0, it would come in,
ask the question, is x less than 2?

30
00:01:54.700 --> 00:01:55.650
Yes, it is.

31
00:01:55.650 --> 00:01:58.340
So it'd run this code and
it would finish down here.

32
00:01:58.340 --> 00:02:03.160
So it would come over here, true,
run, and now skip all the way down.

33
00:02:04.180 --> 00:02:07.140
If you draw blocks,
the box would be this box right here.

34
00:02:07.140 --> 00:02:08.710
It skips out of the box, or

35
00:02:08.710 --> 00:02:12.400
if you draw the box over here,
the box would be right here.

36
00:02:12.400 --> 00:02:15.950
Once you're done with this line of code,
with this block of text right there, or

37
00:02:15.950 --> 00:02:18.160
block of code, you exit the block.

38
00:02:18.160 --> 00:02:20.900
You don't like come back and
look at this question.

39
00:02:20.900 --> 00:02:24.480
You have run, one thing has turned true,
and you're done.

40
00:02:25.590 --> 00:02:31.140
If, on the other hand, x was 5, you would
see a situation where it would come in.

41
00:02:31.140 --> 00:02:33.710
This would be false, and so it would skip.

42
00:02:33.710 --> 00:02:36.460
Then it comes to this next elif,
this becomes true.

43
00:02:36.460 --> 00:02:41.128
So then it jumps in and
does this code, runs out, and is done.

44
00:02:41.128 --> 00:02:42.737
Does not run that,
does not run that, does run that.

45
00:02:42.737 --> 00:02:43.915
So, comes in.

46
00:02:43.915 --> 00:02:46.145
No, it's not less than 2.

47
00:02:46.145 --> 00:02:49.500
It is less than 10, so
we'll run that little block of code, and

48
00:02:49.500 --> 00:02:51.610
now we are all done completely.

49
00:02:51.610 --> 00:02:55.240
So no, no, but yes, okay?

50
00:02:55.240 --> 00:02:56.790
And so that's how it works.

51
00:02:56.790 --> 00:02:58.087
These are done in sequence.

52
00:02:58.087 --> 00:03:01.960
They're not looked at sort of in
parallel or all at the same time.

53
00:03:01.960 --> 00:03:08.426
If, on the other hand, x was 20,
it would say false, skip, question mark.

54
00:03:08.426 --> 00:03:10.313
False, skip.

55
00:03:10.313 --> 00:03:14.552
Oh, else. Then the else always gets
triggered if it gets that far, and

56
00:03:14.552 --> 00:03:16.610
then it runs that one.

57
00:03:16.610 --> 00:03:20.490
So here we say if it's less than 2, no
it's not, is it less than 10, no it's not.

58
00:03:20.490 --> 00:03:23.190
And if it's there, then we just hit
the else part, and we finish and

59
00:03:23.190 --> 00:03:24.370
we continue on.

60
00:03:24.370 --> 00:03:27.540
So this part doesn't run,
this part doesn't run, and that part runs.

61
00:03:27.540 --> 00:03:32.150
The rule is one of the three will run,
and the other two will not.

62
00:03:32.150 --> 00:03:34.460
It only triggers once.

63
00:03:34.460 --> 00:03:37.210
Once it's triggered, then it's
done with the whole if statement.

64
00:03:37.210 --> 00:03:42.140
And again, I think of this as the block,
and you'll see in a second.

65
00:03:42.140 --> 00:03:46.261
Once one of these things hits true, it runs
this and then exits the block completely.

66
00:03:48.000 --> 00:03:49.710
So there's other variations on this.

67
00:03:49.710 --> 00:03:53.440
You can if you want have no else.

68
00:03:53.440 --> 00:03:55.450
So there's no need to have an else.

69
00:03:55.450 --> 00:03:58.259
What we've done is we've simply
deindented this next line.

70
00:03:58.259 --> 00:03:59.891
There's no else here, but that's okay.

71
00:03:59.891 --> 00:04:04.654
It does mean that for some value of,
they might not either execute,

72
00:04:04.654 --> 00:04:07.420
right, because there's no else.

73
00:04:07.420 --> 00:04:09.700
If there's else,
then at least one will execute.

74
00:04:09.700 --> 00:04:13.810
But if there's no else, then it could
be possible that zero executed.

75
00:04:13.810 --> 00:04:18.240
In this case, x is 5,
it's not going to do this one but

76
00:04:18.240 --> 00:04:20.590
it is going to do that one
because x is less than 10.

77
00:04:20.590 --> 00:04:25.049
But if x was, for example,
50, then that would be false,

78
00:04:25.049 --> 00:04:27.591
that would be false, and we just go.

79
00:04:27.591 --> 00:04:31.058
And then neither of these two
things would execute if x were 50.

80
00:04:31.058 --> 00:04:36.080
Okay? So it just means you don't have
to have an else if you don't want to.

81
00:04:37.420 --> 00:04:41.220
Further, you can have lots of elifs.

82
00:04:41.220 --> 00:04:44.990
If x is less than 2, do this,
elif, elif, elif, elif, elif.

83
00:04:44.990 --> 00:04:50.202
And remember, it checks them in order,
first, second, third, fourth, fifth.

84
00:04:51.872 --> 00:04:57.979
So if x was 15, this would be false,
this would be false,

85
00:04:57.979 --> 00:05:02.759
this would be true, so
it would run this code.

86
00:05:02.759 --> 00:05:05.910
And then it would come down
whatever is next down here.

87
00:05:05.910 --> 00:05:08.890
So again, only one of these 
is going to trigger.

88
00:05:08.890 --> 00:05:13.007
No, no, yes, no, no, no.

89
00:05:13.007 --> 00:05:15.192
I mean, 15 is indeed less than 40.

90
00:05:15.192 --> 00:05:19.090
If it came here, it would be true, but
it doesn't matter, because one is triggered,

91
00:05:19.090 --> 00:05:22.720
and so then it takes the entire block,
and there's our entire block.

92
00:05:22.720 --> 00:05:24.230
So as soon as it executes one,

93
00:05:24.230 --> 00:05:27.128
the next thing to do is exit
right out of the block.

94
00:05:27.128 --> 00:05:31.570
Okay, got it?

95
00:05:31.570 --> 00:05:35.160
Okay, so here are a couple of puzzles.

96
00:05:35.160 --> 00:05:37.240
I'll give you a second to pause this.

97
00:05:37.240 --> 00:05:42.466
And the question is, to look at 
some of these, depending on for

98
00:05:42.466 --> 00:05:47.701
a particular value of x,
you will have none of them execute.

99
00:05:47.701 --> 00:05:51.687
So which will never happen for
some particular value of x?

100
00:05:51.687 --> 00:05:54.283
Meaning you can pick any value for
x you want, but

101
00:05:54.283 --> 00:05:57.430
there's some that you
can't cause to execute. Okay?

102
00:05:57.430 --> 00:05:58.640
So I'll pause for a second

103
00:05:58.640 --> 00:06:01.130
and let you pause
the video if you want and

104
00:06:01.130 --> 00:06:02.580
then I'll come back and 
explain it to you.

105
00:06:06.060 --> 00:06:07.310
Okay, you had some time to pause.

106
00:06:07.310 --> 00:06:10.410
Hopefully, you did pause or
didn't pause, but it doesn't matter.

107
00:06:10.410 --> 00:06:13.540
You can still pause while I'm
talking until I start drawing and

108
00:06:13.540 --> 00:06:15.340
telling you the answer.

109
00:06:15.340 --> 00:06:20.360
Okay, so in this one, if x is less than 2,

110
00:06:20.360 --> 00:06:23.670
do this, else if x greater than or
equal to 2.

111
00:06:23.670 --> 00:06:27.080
The one that's never going to
execute is this one right here.

112
00:06:27.080 --> 00:06:30.950
And that's because, no matter what
value of x, it is either less than 

113
00:06:30.950 --> 00:06:32.990
equal to 2 or greater than or equal to 2.

114
00:06:32.990 --> 00:06:37.308
So for any value of x, no matter what you
pick, it's either going to run this one or

115
00:06:37.308 --> 00:06:37.882
this one.

116
00:06:37.882 --> 00:06:41.978
But it's never going to run that one for
any value of x, okay?

117
00:06:41.978 --> 00:06:42.940
So, that's a little tricky.

118
00:06:42.940 --> 00:06:48.441
I just happened to have constructed my
logical questions in such a way that

119
00:06:48.441 --> 00:06:53.603
they covered all values of x, and
so the else was kind of irrelevant.

120
00:06:53.603 --> 00:06:55.550
Now, I wouldn't even draw this this way.

121
00:06:55.550 --> 00:06:58.958
If I was going to draw this,
or write this code,

122
00:06:58.958 --> 00:07:04.520
I would probably just make this be
an else : and this not be there.

123
00:07:04.520 --> 00:07:07.080
But this was more of
a puzzle than anything else.

124
00:07:07.080 --> 00:07:10.546
So in this next one, we have to remember
that these things happen in order.

125
00:07:10.546 --> 00:07:14.037
So if x is less than 2,
we're going to run this.

126
00:07:14.037 --> 00:07:16.100
If it's less than 20,
we're going to run this.

127
00:07:16.100 --> 00:07:17.580
If it's less than 10
we're going to run this.

128
00:07:17.580 --> 00:07:21.207
But the problem is, all values of x 
that are less than 10, for

129
00:07:21.207 --> 00:07:24.231
which this would become true,
this is always true.

130
00:07:24.231 --> 00:07:27.400
So a value like 6, this becomes true.

131
00:07:27.400 --> 00:07:30.760
So that means that if it's something
like 6, it's going to run this and

132
00:07:30.760 --> 00:07:33.660
come out and
never ask this question, right?

133
00:07:33.660 --> 00:07:38.450
So that's the key, even though this
is true and this is true for the 6,

134
00:07:38.450 --> 00:07:41.060
it never even gets here because
this one triggered first.

135
00:07:42.450 --> 00:07:48.320
Okay, and so that's why this is the line
of code that no matter what the value for

136
00:07:48.320 --> 00:07:50.190
x, will never run.

137
00:07:53.180 --> 00:07:58.110
Okay, so the last conditional
code is what's called the try and

138
00:07:58.110 --> 00:07:59.700
except structure.

139
00:07:59.700 --> 00:08:02.990
And if you learn other
programming languages,

140
00:08:02.990 --> 00:08:06.830
this sort of catching errors
is a more advanced concept.

141
00:08:06.830 --> 00:08:11.133
But in Python, we tend to have to use it
earlier because there are things where if

142
00:08:11.133 --> 00:08:13.204
you don't use it, the code blows up.

143
00:08:13.204 --> 00:08:17.639
And the whole idea of a try
except is that you have a bit of

144
00:08:17.639 --> 00:08:22.365
code that you know might fail,
and so you kind of want a take

145
00:08:22.365 --> 00:08:27.302
out an insurance policy on it and
say, hey, give this a try.

146
00:08:27.302 --> 00:08:30.530
If it works, great, if it doesn't,
do this other thing.

147
00:08:30.530 --> 00:08:32.700
Don't blow up, don't get a traceback.

148
00:08:32.700 --> 00:08:37.467
And so this is a way to eliminate or

149
00:08:37.467 --> 00:08:41.020
catch a traceback.

150
00:08:41.020 --> 00:08:42.740
Something that would
otherwise be a traceback.

151
00:08:44.480 --> 00:08:45.830
That's what this is for.

152
00:08:45.830 --> 00:08:49.380
So if you got some line of code, and
you know that this might blow up and

153
00:08:49.380 --> 00:08:53.550
have a traceback,
then you use try/except around it, okay?

154
00:08:53.550 --> 00:08:54.800
So let's take a look at something.

155
00:08:55.940 --> 00:08:59.640
This is a sample we had
from the previous code.

156
00:08:59.640 --> 00:09:04.670
And it comes down, it sticks Hello Bob in,
then it converts this to an integer.

157
00:09:04.670 --> 00:09:08.775
And we know that if these things
are aren't digits, this code blows up, and

158
00:09:08.775 --> 00:09:11.490
so it runs and we get the traceback.

159
00:09:11.490 --> 00:09:16.660
And the traceback happens because of this
line right here, but the key thing about

160
00:09:16.660 --> 00:09:22.650
the traceback is that the traceback,
as I told you before, it stops.

161
00:09:22.650 --> 00:09:25.970
And it stopped at line 2, which means
this is the last line it executed, but

162
00:09:25.970 --> 00:09:28.930
it doesn't continue,
which means this code is gone.

163
00:09:28.930 --> 00:09:32.470
I mean, it never gets there 
because it's like,

164
00:09:32.470 --> 00:09:37.520
I'm confused, I'm quitting,
I have quit at line 2, okay?

165
00:09:37.520 --> 00:09:38.300
I quit at line 2.

166
00:09:40.320 --> 00:09:44.040
So that code, it's as if it's not there.

167
00:09:44.040 --> 00:09:46.841
Now sometimes that's fine with you,
you just want to blow up and

168
00:09:46.841 --> 00:09:49.991
you want to see the message, you want to
go look at line 2 and fix line 2 or

169
00:09:49.991 --> 00:09:51.309
maybe you typed the wrong stuff in.

170
00:09:53.849 --> 00:09:56.570
But sometimes you want to 
control for this.

171
00:09:56.570 --> 00:09:59.053
You want to say, you know what,
I know what I want to do here,

172
00:09:59.053 --> 00:10:01.107
and I don't want to die,
I don't want to blow up.

173
00:10:01.107 --> 00:10:04.963
I want to continue, I want to put
out an error message instead.

174
00:10:04.963 --> 00:10:09.629
And so, the key is, is when this code
blows up, it's something that you kind of

175
00:10:09.629 --> 00:10:13.378
take personally because you
are that set of instructions, and

176
00:10:13.378 --> 00:10:18.890
when a traceback happens inside the memory
or CPU, that's you that's being vaporized.

177
00:10:18.890 --> 00:10:21.710
You've been traced back, and so
we take it kind of personally.

178
00:10:21.710 --> 00:10:25.160
I mean, if you were to use software
that I built, like the autograder for

179
00:10:25.160 --> 00:10:28.000
this class and
you started getting tracebacks,

180
00:10:28.000 --> 00:10:31.420
I'm like, hey,
that's kind of a personal thing.

181
00:10:31.420 --> 00:10:33.950
I didn't do my job well,
I didn't catch all the errors.

182
00:10:33.950 --> 00:10:35.390
I didn't think of everything.

183
00:10:35.390 --> 00:10:37.910
You could type something that
will cause my code to blow up.

184
00:10:37.910 --> 00:10:39.580
And so I take that kind of personally.

185
00:10:39.580 --> 00:10:42.110
And so we have to be able to 
compensate for

186
00:10:42.110 --> 00:10:44.740
situations that we know
might cause errors.

187
00:10:44.740 --> 00:10:47.480
Especially those where
the user can type something

188
00:10:47.480 --> 00:10:48.850
that can cause my program to blow up.

189
00:10:48.850 --> 00:10:52.020
That's really, like,
I'm going to let you blow my program up?

190
00:10:52.020 --> 00:10:53.800
I am going to compensate.

191
00:10:53.800 --> 00:10:55.750
I'll tell you, sorry, that's bad data.

192
00:10:55.750 --> 00:10:58.290
But I don't want you to
ever see a traceback

193
00:10:58.290 --> 00:11:01.870
because it's kind of shameful to see
a traceback for a professional programmer.

194
00:11:01.870 --> 00:11:08.720
Okay, so here's how it works, it's a bit
of stuff with some indentation and colons.

195
00:11:08.720 --> 00:11:11.780
It looks like a lot, but
don't worry, you'll figure it out.

196
00:11:11.780 --> 00:11:17.540
So the idea is, is you have a line
of code that you know is dangerous.

197
00:11:17.540 --> 00:11:19.170
So this conversion of an integer,

198
00:11:19.170 --> 00:11:22.140
let's just say this came
from an input statement.

199
00:11:22.140 --> 00:11:23.660
In this case,
we'll just make it be Hello Bob.

200
00:11:23.660 --> 00:11:25.520
We know this is going to fail.

201
00:11:25.520 --> 00:11:30.219
And so, this is the line in which we
kind of want to take out insurance on it.

202
00:11:30.219 --> 00:11:32.120
So instead of just putting
this line in here,

203
00:11:32.120 --> 00:11:37.040
like we did in the previous example,
we just had it right there.

204
00:11:37.040 --> 00:11:40.220
Instead of taking that line there, we'd say,
you know what, we're going to take and

205
00:11:40.220 --> 00:11:42.110
stick this in a try and except block.

206
00:11:42.110 --> 00:11:43.470
So we say the word try.

207
00:11:43.470 --> 00:11:46.825
Try ends in a colon, which means
it's an indented block of code.

208
00:11:46.825 --> 00:11:51.260
And then we put the dangerous line
in there, and then we put except.

209
00:11:51.260 --> 00:11:54.940
And then the except is kind of
like an else, an if-then-else, but

210
00:11:54.940 --> 00:11:59.320
what it really is is code that Python
will execute if something goes wrong.

211
00:11:59.320 --> 00:12:02.770
So this is either going to run and
work and skip this.

212
00:12:02.770 --> 00:12:07.762
Or if it goes bad, it's going to run,
blow up, and then run this stuff and

213
00:12:07.762 --> 00:12:09.107
then continue on.

214
00:12:09.107 --> 00:12:13.348
But in no case you will get a traceback,
meaning if this line is going to generate

215
00:12:13.348 --> 00:12:16.430
a traceback,
it actually just runs the except clause.

216
00:12:16.430 --> 00:12:19.597
So it's kind of like if things work out,
do this,

217
00:12:19.597 --> 00:12:22.782
if things don't work out,
do this other thing.

218
00:12:22.782 --> 00:12:28.095
So in this case, when this runs, this is
going to fail, because that's Hello Bob.

219
00:12:28.095 --> 00:12:31.050
And then it's going to come out here and
set this to -1.

220
00:12:31.050 --> 00:12:32.349
So that's going to blow up.

221
00:12:32.349 --> 00:12:34.189
Set this to -1,
that's going to print it out.

222
00:12:34.189 --> 00:12:36.988
So it says, First equals -1.

223
00:12:36.988 --> 00:12:38.925
And so we didn't traceback.

224
00:12:38.925 --> 00:12:42.476
In the previous time we ran this,
it traced back because we caught it.

225
00:12:42.476 --> 00:12:47.010
Now, the way the try/except works is,
if everything is fine, it has no effect.

226
00:12:47.010 --> 00:12:51.306
So if we, the next thing we're going to
convert is 123, the digits, 1, 2, 3,

227
00:12:51.306 --> 00:12:52.156
in a string.

228
00:12:52.156 --> 00:12:56.972
We do a try, and we try to convert it and
it works, and so we just keep on going.

229
00:12:56.972 --> 00:12:58.188
We don't run the except.

230
00:12:58.188 --> 00:13:01.397
So this code does not run
because this code succeeded,

231
00:13:01.397 --> 00:13:04.625
there was no traceback that
was going to be generated.

232
00:13:04.625 --> 00:13:06.504
There's a traceback generated up here.

233
00:13:06.504 --> 00:13:10.286
There was no traceback generated here,
so it comes through, and

234
00:13:10.286 --> 00:13:13.259
the result is istr ends up 
with a integer, 123.

235
00:13:13.259 --> 00:13:18.555
And so it's an insurance policy or
it says, I know this might blow up and

236
00:13:18.555 --> 00:13:23.700
if it does, I'm giving you alternate
text or alternate code to run.

237
00:13:25.550 --> 00:13:29.810
So the thing about the try/except block,
and you might be tempted to do this, and

238
00:13:29.810 --> 00:13:32.500
that is,
if you're getting tired of tracebacks and

239
00:13:32.500 --> 00:13:36.690
blowing up, you might want to put your
entire program in a try and except block.

240
00:13:36.690 --> 00:13:38.640
And you might say try blah,
blah, blah, blah, and

241
00:13:38.640 --> 00:13:39.900
then except something bad happens.

242
00:13:39.900 --> 00:13:41.640
The problem is,
is if your program's blowing up,

243
00:13:41.640 --> 00:13:43.360
you actually want to know about it.

244
00:13:43.360 --> 00:13:47.190
And the way the try and except block works
is, if it's in the middle of a try and

245
00:13:47.190 --> 00:13:51.200
except block and something goes wrong,
like in this particular line,

246
00:13:51.200 --> 00:13:53.810
it doesn't come back and
finish the try and except block.

247
00:13:53.810 --> 00:13:57.450
It actually exits to the except and
then comes out.

248
00:13:57.450 --> 00:14:01.000
And to draw this in a diagram,
so here we go,

249
00:14:01.000 --> 00:14:03.670
we start this thing,
we're in the try block.

250
00:14:03.670 --> 00:14:06.650
We're doing print,
print's safe, doesn't hurt anything.

251
00:14:06.650 --> 00:14:10.135
We do this,
this blows up with a traceback.

252
00:14:10.135 --> 00:14:13.550
Traceback and
then that says go to the except block,

253
00:14:13.550 --> 00:14:16.350
run whatever is in the except block and
then continue on.

254
00:14:16.350 --> 00:14:21.210
What's not going to happen is it's not
going to go back up and do this, or

255
00:14:21.210 --> 00:14:22.695
back up and try this one again.

256
00:14:22.695 --> 00:14:24.410
No, no, no, no, no.

257
00:14:24.410 --> 00:14:28.408
Once it gets the except block,
there's only one way out to the bottom, so

258
00:14:28.408 --> 00:14:30.292
this line of code never executes.

259
00:14:30.292 --> 00:14:33.481
And so that's one of the things
we try to do where we just,

260
00:14:33.481 --> 00:14:35.430
you don't put too much stuff in.

261
00:14:35.430 --> 00:14:38.910
You would put this print statement out
here and this print statement out here,

262
00:14:38.910 --> 00:14:41.960
and you'd only put one line in
the try/except block, if possible.

263
00:14:41.960 --> 00:14:46.060
Sometimes you put a few more lines
in there, but you try to minimize.

264
00:14:48.340 --> 00:14:50.350
You know what line is dangerous.

265
00:14:50.350 --> 00:14:53.740
Print is not dangerous,
these two prints are not really dangerous,

266
00:14:53.740 --> 00:14:55.080
don't put them in the block.

267
00:14:55.080 --> 00:14:58.664
Because any line in the block, as soon
as it hits a bad line with a traceback,

268
00:14:58.664 --> 00:15:01.641
it's out of the block,
runs the except, and then continues on.

269
00:15:03.338 --> 00:15:07.286
So here's a more practical example,

270
00:15:09.511 --> 00:15:13.366
Where we're going to read
a number from the user and

271
00:15:13.366 --> 00:15:16.605
print out either Nice work or
Not a number.

272
00:15:16.605 --> 00:15:21.478
And so, we take an input statement,
which stops and waits for

273
00:15:21.478 --> 00:15:24.205
us to type, and then we type 42.

274
00:15:24.205 --> 00:15:29.670
And 42 goes into rawstr and
then we know that this int is dangerous.

275
00:15:29.670 --> 00:15:33.870
Right? And this rawstr came from the user,
whatever the user typed.

276
00:15:33.870 --> 00:15:40.180
And so we put it in the try block,
and if it's 42, it converts and

277
00:15:40.180 --> 00:15:44.540
it says ival is greater than 0,
we print it out, so it says Nice work.

278
00:15:44.540 --> 00:15:47.541
Now, we'll run this code again.

279
00:15:47.541 --> 00:15:52.098
Okay, we run it a second time and
now we enter something, it says forty-two

280
00:15:52.098 --> 00:15:53.911
but it's like f-o-r-t-y.

281
00:15:53.911 --> 00:15:56.320
And so forty-two is what goes in here.

282
00:15:56.320 --> 00:16:00.730
We as the programmer had no control over
what our crazy user was typing, right?

283
00:16:00.730 --> 00:16:04.528
You're starting to be a programmer and
crazy users do crazy things to your poor

284
00:16:04.528 --> 00:16:07.080
programs, even if they're
only like seven lines long.

285
00:16:07.080 --> 00:16:09.590
So we got forty-two coming in here,

286
00:16:09.590 --> 00:16:13.600
we know this is going to blow up, this
int is going to blow up with a traceback.

287
00:16:15.990 --> 00:16:18.900
But that's okay, we've compensated for
that and we told Python, hey,

288
00:16:18.900 --> 00:16:21.970
we know that might happen and
if you detect a traceback,

289
00:16:21.970 --> 00:16:27.460
jump straight into the except block, run
this, set it to -1, and then continue on.

290
00:16:27.460 --> 00:16:29.830
So this is the de-indent of
the try/except block, and

291
00:16:29.830 --> 00:16:31.685
if it's greater than 0 we say Nice work.

292
00:16:31.685 --> 00:16:35.430
But in this case, it's not, and
we say, Not a number, and so

293
00:16:35.430 --> 00:16:37.315
it comes out with Not a number.

294
00:16:37.315 --> 00:16:39.280
What's not here is a traceback.

295
00:16:39.280 --> 00:16:42.730
There is no traceback in this,
that's what we achieved.

296
00:16:42.730 --> 00:16:44.740
And it doesn't hurt.

297
00:16:44.740 --> 00:16:49.350
When it works, the try/except kind of
does nothing because the except code,

298
00:16:49.350 --> 00:16:51.060
when it works, is ignored.

299
00:16:51.060 --> 00:16:55.260
So it's like code you add in case
something happens in an other line of code.

300
00:16:56.290 --> 00:16:57.245
Pretty cool, actually.

301
00:16:59.775 --> 00:17:04.520
So you have a couple exercises and
I've got some videos of those exercises.

302
00:17:04.520 --> 00:17:05.560
So in summary,

303
00:17:05.560 --> 00:17:10.610
what we talked about in this chapter is
comparison operators, logical questions.

304
00:17:10.610 --> 00:17:14.050
A key is that these comparison
operators don't change their arguments.

305
00:17:14.050 --> 00:17:17.840
You can say if x is less than 5,
doesn't change the value for x.

306
00:17:17.840 --> 00:17:21.433
We have indentation and
how important indentation is.

307
00:17:23.540 --> 00:17:27.800
One-way decisions with if,
two-way decisions with if-then-else.

308
00:17:27.800 --> 00:17:31.120
Nested decisions where you have an if
inside of an if that moves on in.

309
00:17:31.120 --> 00:17:36.800
Else-if, and then try and except to catch
errors that you want to catch, okay?

310
00:17:36.800 --> 00:17:38.130
So, thanks a lot.