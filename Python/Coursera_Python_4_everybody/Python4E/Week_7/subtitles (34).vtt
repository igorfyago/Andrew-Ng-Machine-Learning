WEBVTT

1
00:00:09.131 --> 00:00:11.640
So now what we're going to do is
we're going to keep working on this.

2
00:00:11.640 --> 00:00:13.880
We're going to do something in the loop,
we're going to do something before and

3
00:00:13.880 --> 00:00:14.570
something after.

4
00:00:14.570 --> 00:00:16.000
And we're going to
accomplish different things.

5
00:00:16.000 --> 00:00:20.360
So the first thing that we're going to
accomplish is counting something, right?

6
00:00:20.360 --> 00:00:23.200
I'm counting the number of things that
we are going to be looping through.

7
00:00:23.200 --> 00:00:25.500
Now, in this case, it's kind of silly.

8
00:00:25.500 --> 00:00:29.180
But, just, in general,
these are called counters.

9
00:00:29.180 --> 00:00:32.720
So, let's just say we had dot dot dot
dot, a whole bunch of these things.

10
00:00:32.720 --> 00:00:34.280
And we didn't exactly,
we can look at this and

11
00:00:34.280 --> 00:00:36.520
say there are six of them,
that's not the point.

12
00:00:36.520 --> 00:00:38.200
The point is, if we have a loop and

13
00:00:38.200 --> 00:00:41.320
in loop we want to keep track
of how many we've seen.

14
00:00:41.320 --> 00:00:43.990
Well, you do this counting thing, okay?

15
00:00:43.990 --> 00:00:47.750
So the way it works is
you set a variable to 0.

16
00:00:47.750 --> 00:00:51.878
This is the top part, normally this would
be called count, but I'm going to use

17
00:00:51.878 --> 00:00:55.961
a bad non-mnemonic value called zork,
just so you don't get too used to it.

18
00:00:55.961 --> 00:00:58.610
So we so far how many have we seen?

19
00:00:58.610 --> 00:00:59.284
Well we've seen 0.

20
00:00:59.284 --> 00:01:03.880
And then we're going to go it
thing is going to be 9, 41, 12.

21
00:01:03.880 --> 00:01:06.300
So thing is going to be
the iteration variable.

22
00:01:06.300 --> 00:01:08.887
Each time through the loop,
we're going to add 1 to zork,

23
00:01:08.887 --> 00:01:11.337
increment is another word for
this, zork = zork + 1.

24
00:01:11.337 --> 00:01:13.160
We print out the thing
we're looking at and

25
00:01:13.160 --> 00:01:15.320
we print out the current value for zork.

26
00:01:15.320 --> 00:01:19.500
So, the first time through 9, and then,
that's the first thing we saw, 41,

27
00:01:19.500 --> 00:01:21.600
the second.

28
00:01:21.600 --> 00:01:25.180
So, and each time, this goes up by 1.

29
00:01:25.180 --> 00:01:28.910
It doesn't really matter what these things
are, but then, we run this many times.

30
00:01:28.910 --> 00:01:32.500
And when we're done then we say,
okay, loop is all done, right?

31
00:01:32.500 --> 00:01:34.030
There's the end of the block.

32
00:01:34.030 --> 00:01:36.550
And when it's all said and
done, there were 6 things.

33
00:01:36.550 --> 00:01:38.340
Now again, 6 is kind of obvious.

34
00:01:38.340 --> 00:01:40.650
We could just look at it and
know that there are 6.

35
00:01:40.650 --> 00:01:44.150
But this is a way to keep track of the
number of times that a loop is executed.

36
00:01:44.150 --> 00:01:48.446
You set it to 0 at the place, you add 1
to it, and then you print out the end.

37
00:01:48.446 --> 00:01:52.636
At the beginning, before it starts set
it to 0, add 1 each time through, and

38
00:01:52.636 --> 00:01:54.658
then print out the count at the end.

39
00:01:54.658 --> 00:01:58.820
So that's counting.

40
00:01:58.820 --> 00:02:02.060
The next thing we're going to do
is total up a series of values.

41
00:02:02.060 --> 00:02:03.530
So in this case we're
going to total them up.

42
00:02:03.530 --> 00:02:07.127
It makes a lot more sense now and we're
going to have another variable, zork.

43
00:02:07.127 --> 00:02:10.150
I would probably call this total.

44
00:02:10.150 --> 00:02:12.530
During the loop, 
it'll be the running total and

45
00:02:12.530 --> 00:02:15.340
at the end of loop it will be the total.

46
00:02:15.340 --> 00:02:22.990
And so total = 0, before we, that's
the running total of what we have seen.

47
00:02:22.990 --> 00:02:27.960
So now 9 comes out and 0 + 9 is 9, so

48
00:02:27.960 --> 00:02:32.500
the running total is 9 and
9 was what we looked at.

49
00:02:32.500 --> 00:02:35.500
Then 41 comes in, then we take 9 plus 41.

50
00:02:35.500 --> 00:02:39.820
Running total's 50, we read 41,
go back up, 12 comes in.

51
00:02:39.820 --> 00:02:43.219
50 plus 12 is 62.

52
00:02:43.219 --> 00:02:45.290
So, that's our running total.

53
00:02:45.290 --> 00:02:46.530
Next time we get 3.

54
00:02:46.530 --> 00:02:49.276
62 plus 3 is 65.

55
00:02:49.276 --> 00:02:51.065
So, this line prints out.

56
00:02:51.065 --> 00:02:52.311
Then we get 74.

57
00:02:52.311 --> 00:02:57.456
So, 65 plus 74 is 139.

58
00:02:57.456 --> 00:02:58.460
So, that's the running total.

59
00:02:58.460 --> 00:03:00.223
We go and do the last one, 15.

60
00:03:00.223 --> 00:03:02.815
139 plus 15 is 154.

61
00:03:02.815 --> 00:03:04.210
We print that out.

62
00:03:04.210 --> 00:03:07.660
And now it goes back up but the for
loop is done, so out we come.

63
00:03:07.660 --> 00:03:09.480
So at the end, when it's all said and

64
00:03:09.480 --> 00:03:14.030
done, this this running total
become the total, 154.

65
00:03:14.030 --> 00:03:17.430
So, we know certainly when you
print all that stuff out, right,

66
00:03:17.430 --> 00:03:18.720
you wouldn't print that out.

67
00:03:18.720 --> 00:03:20.550
But at the end if you do this.

68
00:03:20.550 --> 00:03:25.210
And so the difference between the count
and the total is instead of adding 1 here,

69
00:03:25.210 --> 00:03:27.850
you add the thing you're running
that you're totaling up.

70
00:03:28.930 --> 00:03:31.090
So that's how we compute totals.

71
00:03:32.350 --> 00:03:35.320
And of course,
we can do this with an average, right?`

72
00:03:35.320 --> 00:03:37.977
So now we're going to have
a counter which we set to 0,

73
00:03:37.977 --> 00:03:40.677
a running total which we set to 0 in
the variable sum.

74
00:03:40.677 --> 00:03:42.560
We're going to print out 0, 0.

75
00:03:42.560 --> 00:03:44.210
So, the count and the total is 0.

76
00:03:44.210 --> 00:03:45.330
We run through.

77
00:03:45.330 --> 00:03:47.280
Each time through, we add 1.

78
00:03:47.280 --> 00:03:51.140
So, it's going to be 1, 2, 3,
4, 5, 6 each time through.

79
00:03:51.140 --> 00:03:58.024
And we have the sum = sum + value,
so, 9, 50, 62, 65, 139, 154.

80
00:03:58.024 --> 00:04:00.470
So this is the running total.

81
00:04:00.470 --> 00:04:02.310
This is the count.

82
00:04:02.310 --> 00:04:05.270
Actually that's the sum in this case,
the sum variable.

83
00:04:05.270 --> 00:04:08.177
And then,
this is the thing that we're reading in.

84
00:04:08.177 --> 00:04:09.840
And then we finally get done.

85
00:04:09.840 --> 00:04:11.510
because there was only six things.

86
00:04:11.510 --> 00:04:12.840
The for loop dumps this out.

87
00:04:12.840 --> 00:04:15.340
And then we got, okay, 
how many did we get?

88
00:04:15.340 --> 00:04:16.080
We got 6.

89
00:04:16.080 --> 00:04:18.220
What was the total?
It was 154.

90
00:04:18.220 --> 00:04:21.785
And then divide sum by count and
that should be 25.0.

91
00:04:22.850 --> 00:04:27.800
Okay? And so we divide sum by count and
now we have calculated the average,

92
00:04:27.800 --> 00:04:30.981
actually this should be 154 divided by 6.

93
00:04:30.981 --> 00:04:38.235
I think that should be 25.6666 or
something like that. Okay?

94
00:04:38.235 --> 00:04:41.035
So you get the idea, and so you sum and so

95
00:04:41.035 --> 00:04:46.185
you can do more than one of these
things in a particular loop.

96
00:04:46.185 --> 00:04:51.610
Now, filtering is the idea that we're looking
for something that meets some criteria.

97
00:04:51.610 --> 00:04:54.930
So we're going to go through and
look at all the things in the loop.

98
00:04:54.930 --> 00:04:58.570
And we're trying to figure out if
something is greater than 20 and

99
00:04:58.570 --> 00:05:00.660
we're going to declare that large number.

100
00:05:00.660 --> 00:05:02.420
So this is how you put an if in the loop.

101
00:05:02.420 --> 00:05:04.560
So sometimes this loop will do nothing,

102
00:05:04.560 --> 00:05:07.050
sometimes this loop will
print out Large number.

103
00:05:07.050 --> 00:05:11.450
And so, value is going to be 9 and
that's false, so it doesn't do anything.

104
00:05:11.450 --> 00:05:14.870
Value is 41, that's true,
so it prints out this.

105
00:05:14.870 --> 00:05:16.990
Value's 12, so it does nothing.

106
00:05:16.990 --> 00:05:18.830
Value's 3, it does nothing.

107
00:05:18.830 --> 00:05:21.340
Value's 74 and so it prints this out.

108
00:05:21.340 --> 00:05:24.190
Value's 15, so that's false. Done.

109
00:05:24.190 --> 00:05:27.470
Now the for loop knows oh, we're done,
go on to the next line. Okay?

110
00:05:29.140 --> 00:05:34.610
So this is kind of a filtering pattern
where we are going to do some if statement

111
00:05:34.610 --> 00:05:39.330
and conditionally run some code based on
the value that we are looking at for now.

112
00:05:39.330 --> 00:05:45.720
So that's like searching for
large numbers in our long list of numbers.

113
00:05:48.320 --> 00:05:51.411
Sometimes instead of printing something
out in the middle of the loop, just like in

114
00:05:51.411 --> 00:05:53.481
functions, we don't often
print in functions.

115
00:05:53.481 --> 00:05:58.358
We tend to prefer using return values,
sometimes we just want a variable that

116
00:05:58.358 --> 00:06:02.140
tells us whether something was 
found or not.

117
00:06:02.140 --> 00:06:04.280
And so
we're going to use a boolean variable.

118
00:06:04.280 --> 00:06:06.430
So boolean is another type of a variable.

119
00:06:06.430 --> 00:06:10.300
You've got integer variables, you've got string
variables, you've got floating point variables.

120
00:06:10.300 --> 00:06:12.050
Boolean is another kind of variable.

121
00:06:12.050 --> 00:06:15.490
Boolean is a kind of variable that either
has the value True or False,

122
00:06:15.490 --> 00:06:19.150
that's it, it can only have two.

123
00:06:19.150 --> 00:06:21.450
And so False is a constant in Python.

124
00:06:21.450 --> 00:06:23.063
And so I'm going to say found.

125
00:06:23.063 --> 00:06:26.852
found is a mnemonic variable. I use
the word found for this all the time, but

126
00:06:26.852 --> 00:06:28.110
don't get stuck on it.

127
00:06:28.110 --> 00:06:31.230
It just happens to be a variable
with the value False.

128
00:06:31.230 --> 00:06:34.140
So we print it out before, it's False.

129
00:06:34.140 --> 00:06:37.470
And now we're going to go through
each of these values again.

130
00:06:37.470 --> 00:06:39.180
And we're looking for 3.

131
00:06:39.180 --> 00:06:41.126
And we want to know did we find 3 or not.

132
00:06:41.126 --> 00:06:43.682
So we have 9.

133
00:06:44.700 --> 00:06:46.027
And it stays False.

134
00:06:46.027 --> 00:06:48.104
We have 41, it stays False.

135
00:06:48.104 --> 00:06:51.599
We have 12, stays False.

136
00:06:51.599 --> 00:06:55.668
Now we have 3,
this all of a sudden clicks to True and so

137
00:06:55.668 --> 00:07:01.610
then we change the variable found, which
is the same found here, to be True.

138
00:07:01.610 --> 00:07:07.700
So this time when we come out up to 3
we run this code, then we print this, and

139
00:07:07.700 --> 00:07:08.780
it's True.

140
00:07:08.780 --> 00:07:13.080
Now at 74, this is False, but
we've changed the variable for found, so

141
00:07:13.080 --> 00:07:14.630
it doesn't change back to False.

142
00:07:15.850 --> 00:07:17.541
So we run the rest of the loop.

143
00:07:17.541 --> 00:07:20.600
And when we're done, True.

144
00:07:20.600 --> 00:07:26.157
And so, at some level,
if you didn't print all this stuff out.

145
00:07:27.435 --> 00:07:30.913
Before, after, that means we found a 3.

146
00:07:30.913 --> 00:07:34.009
There could be a million
times that we ran this and

147
00:07:34.009 --> 00:07:37.418
all we know when we're done
is there was a 3 in there.

148
00:07:37.418 --> 00:07:39.430
So that's what it's saying.

149
00:07:39.430 --> 00:07:42.180
Found starts out False, it loops and
loops and loops and loops.

150
00:07:42.180 --> 00:07:44.770
And if it ever finds it
then found becomes True and

151
00:07:44.770 --> 00:07:48.240
then we can detect by the loop,
yes we found it.

152
00:07:48.240 --> 00:07:50.000
Yes, that happened.

153
00:07:50.000 --> 00:07:53.980
No matter how many numbers we looked at,
one of them at one point,

154
00:07:53.980 --> 00:07:56.001
at least one of them was a 3.

155
00:07:57.190 --> 00:07:59.880
Now, if we were a little tricky we
would realize that we could put

156
00:07:59.880 --> 00:08:00.680
a break right here.

157
00:08:02.580 --> 00:08:06.010
Right there, because once it's True
it's not going to go back to False,

158
00:08:06.010 --> 00:08:06.560
so we could stop.

159
00:08:08.340 --> 00:08:10.934
So we've done a bunch of different
things, right? We found the largest,

160
00:08:10.934 --> 00:08:11.791
we searched for a value.

161
00:08:11.791 --> 00:08:14.534
We did some sums,
we did some averages and now,

162
00:08:14.534 --> 00:08:16.740
we're going to do the smallest value.

163
00:08:17.760 --> 00:08:21.410
So, just before we do the smallest
value let's review what we did for

164
00:08:21.410 --> 00:08:22.130
the largest value.

165
00:08:23.520 --> 00:08:27.077
Okay, and so, we have this variable
called largest_so_far

166
00:08:27.077 --> 00:08:32.607
that we set to -1, and then we 
print it out, it starts being -1.

167
00:08:32.607 --> 00:08:35.683
And then we're going to
go through this loop, 9.

168
00:08:35.683 --> 00:08:38.931
And the largest so
far is 9 and then we go 41.

169
00:08:38.931 --> 00:08:40.803
We like that one better. Then we hit 12.

170
00:08:40.803 --> 00:08:41.550
We don't want that.

171
00:08:41.550 --> 00:08:43.181
We went 3, we don't want that.

172
00:08:43.181 --> 00:08:46.761
74, we keep that and
then 15 doesn't make any difference.

173
00:08:46.761 --> 00:08:50.530
Then it pops out and we get 74.

174
00:08:50.530 --> 00:08:54.870
That is the largest, not the largest so
far, but the largest you would get.

175
00:08:54.870 --> 00:08:59.470
So the question is, what would you do

176
00:08:59.470 --> 00:09:03.990
to change this to make it search for
the smallest value in the list?

177
00:09:03.990 --> 00:09:06.600
Now you can look, humans are good at this.

178
00:09:06.600 --> 00:09:07.760
Like hey, what's the smallest value?

179
00:09:07.760 --> 00:09:10.140
It's 3, yeah of course, you know that.

180
00:09:10.140 --> 00:09:11.480
No, we've got to think like a computer.

181
00:09:12.730 --> 00:09:14.871
How are we going to find
the smallest value in the list?

182
00:09:14.871 --> 00:09:15.913
What would we change here?

183
00:09:15.913 --> 00:09:20.391
What are some of things you might change?

184
00:09:20.391 --> 00:09:25.369
There is at least couple things
you would change, right?

185
00:09:25.369 --> 00:09:27.428
So the first thing you would do is,

186
00:09:27.428 --> 00:09:31.410
let's just change this from a greater
than sign to a less than sign.

187
00:09:32.520 --> 00:09:34.770
And let's just change
the word large to small.

188
00:09:47.558 --> 00:09:49.560
Is that going to fix it?

189
00:09:51.800 --> 00:09:55.840
Take a second, if I changed all the word
largest to the word smallest, and

190
00:09:55.840 --> 00:09:59.020
I changed the greater than to a less than,
is that going to fix it?

191
00:09:59.020 --> 00:10:02.500
If I did that,
what number's going to come out here?

192
00:10:04.190 --> 00:10:07.450
Is it going to be 3?
Is that going to come out?

193
00:10:13.864 --> 00:10:14.987
So, like, if I did this?

194
00:10:19.049 --> 00:10:20.670
Is that going to make it better?

195
00:10:20.670 --> 00:10:23.162
Is it going to print 3?

196
00:10:23.162 --> 00:10:25.684
Obviously if I'm staring at you,
probably it's not going to,

197
00:10:25.684 --> 00:10:27.050
this was trick question, right?

198
00:10:27.050 --> 00:10:29.020
It was a trick question.

199
00:10:29.020 --> 00:10:30.730
This is what happens when you run it.

200
00:10:33.601 --> 00:10:39.117
So you start out, smallest_so_far is -1.

201
00:10:39.117 --> 00:10:40.978
We come in with 9.

202
00:10:40.978 --> 00:10:43.270
Is 9 less than -1?

203
00:10:43.270 --> 00:10:45.580
No, it is not, so we skip.

204
00:10:46.620 --> 00:10:50.450
So, the smallest we've seen so
far is -1, and we go back up.

205
00:10:50.450 --> 00:10:51.892
Is 41 less than -1?

206
00:10:51.892 --> 00:10:54.710
No, it is not, so we skip.

207
00:10:54.710 --> 00:10:56.679
So the smallest so far, is -1.

208
00:10:56.679 --> 00:10:57.708
12? No.

209
00:10:57.708 --> 00:11:01.944
3 is not smaller than -1,
74 is not smaller than -1.

210
00:11:03.640 --> 00:11:05.600
15 is not smaller than -1.

211
00:11:05.600 --> 00:11:09.176
So out we come and the 
smallest we've seen so far is -1.

212
00:11:13.792 --> 00:11:15.996
No, it is not.

213
00:11:15.996 --> 00:11:19.587
So, what's the flaw in our logic here?

214
00:11:19.587 --> 00:11:23.020
First off, the word smallest so
far doesn't mean anything.

215
00:11:23.020 --> 00:11:26.020
This could be gorp or zap or x.

216
00:11:26.020 --> 00:11:30.793
So just changing the variable to say
smallest so far is highly misleading, okay?

217
00:11:30.793 --> 00:11:35.990
So, at this point, point right

218
00:11:35.990 --> 00:11:40.900
at the screen to the one place that has
the fallacy, the mistake in this code.

219
00:11:43.525 --> 00:11:47.730
If you pointed right here,
you're correct, right?

220
00:11:47.730 --> 00:11:49.980
So baked into that when
we were doing largest so far

221
00:11:49.980 --> 00:11:52.920
was that these are positive numbers.

222
00:11:52.920 --> 00:11:57.760
And smallest_so_far, 
if we're starting at -1.

223
00:11:57.760 --> 00:11:59.470
If they are positive numbers,
well smallest_so_far

224
00:11:59.470 --> 00:12:02.650
is already smallest than
the smallest possible numbers.

225
00:12:02.650 --> 00:12:07.830
So what number might we put
there to make this work better?

226
00:12:07.830 --> 00:12:12.873
Well, some of you might suggest that
we would just say, that would be okay.

227
00:12:12.873 --> 00:12:14.670
I'll make that be 100.

228
00:12:14.670 --> 00:12:16.469
It's going to work fine, right?

229
00:12:16.469 --> 00:12:21.126
9 will tick, 41 will ignore, 
12 will not work,

230
00:12:21.126 --> 00:12:25.950
3 will tick. And it will work,
it will work, that's fine.

231
00:12:25.950 --> 00:12:28.000
That would work if you made it 100.

232
00:12:28.000 --> 00:12:33.900
But then what if there were three-digit
numbers in here, how will that work?

233
00:12:33.900 --> 00:12:35.385
Well, let's make it 1,000.

234
00:12:36.440 --> 00:12:37.560
Yeah, that's it.

235
00:12:37.560 --> 00:12:43.860
No, no, no, let's make it a million,
or like more, right?

236
00:12:43.860 --> 00:12:44.780
What's a big enough number?

237
00:12:46.020 --> 00:12:49.790
As a matter of fact, largest so,
that largest so far code that we did,

238
00:12:51.590 --> 00:12:53.330
if there were negative numbers, and

239
00:12:53.330 --> 00:12:55.630
they're all negative,
this is not going to work so well.

240
00:12:55.630 --> 00:12:59.150
Wait, larger so far, yeah.

241
00:12:59.150 --> 00:13:01.270
This is just not going to work very well.

242
00:13:01.270 --> 00:13:02.580
Because what if they're
all negative numbers?

243
00:13:02.580 --> 00:13:04.140
We just assumed they were
positive numbers, and

244
00:13:04.140 --> 00:13:05.140
it worked just fine, didn't it?

245
00:13:06.550 --> 00:13:10.450
Whoops, whoops, whoops,
whoops, whoops, okay.

246
00:13:10.450 --> 00:13:11.950
So, there's kind of a flaw.

247
00:13:13.010 --> 00:13:17.310
We were using this -1,
there's a word for it.

248
00:13:17.310 --> 00:13:22.810
It is kind of like a flag value, it's not
really the smallest number we have seen.

249
00:13:23.880 --> 00:13:26.690
It's like an indicator that
we haven't seen any numbers.

250
00:13:30.490 --> 00:13:33.890
And we can't really pick 
a number for this.

251
00:13:33.890 --> 00:13:37.304
Frankly, either in the largest or the
smallest, it's just not going to work.

252
00:13:37.304 --> 00:13:38.675
So what are we going to do?

253
00:13:38.675 --> 00:13:43.240
Okay, so, this is what we do.

254
00:13:44.300 --> 00:13:48.407
We have yet another type of variable,
remember I had boolean, True and False,

255
00:13:48.407 --> 00:13:49.890
integer, floating point.

256
00:13:49.890 --> 00:13:53.450
There is a variable called None type,
None.

257
00:13:53.450 --> 00:13:55.580
It only has one constant in it.

258
00:13:55.580 --> 00:13:59.530
So booleans have true and false,
integers have a whole bunch, and

259
00:13:59.530 --> 00:14:04.440
then floats have a whole bunch, and
None types have one thing, None.

260
00:14:04.440 --> 00:14:07.620
We think of it as the absence of a value.

261
00:14:07.620 --> 00:14:09.770
The lack of a value, okay?

262
00:14:09.770 --> 00:14:11.250
And so,

263
00:14:11.250 --> 00:14:13.920
what we're going to do instead, is in our
smallest variable, that we're going to do.

264
00:14:13.920 --> 00:14:14.890
We're going to say, you know what,

265
00:14:14.890 --> 00:14:20.220
before this loop starts,
the smallest number we've seen is nothing.

266
00:14:20.220 --> 00:14:22.140
We've seen no numbers whatsoever.

267
00:14:22.140 --> 00:14:26.320
And that's going to be our marker to
indicate that we've seen no numbers. Okay?

268
00:14:26.320 --> 00:14:30.435
This is kind of like the found code
where we set found to be False and

269
00:14:30.435 --> 00:14:32.660
then later we set found to be True.

270
00:14:33.960 --> 00:14:36.600
But we're going to use
smallest equals None.

271
00:14:36.600 --> 00:14:41.546
None is a variable, a value, that we can
distinctly detect different than numbers.

272
00:14:41.546 --> 00:14:48.220
So we can say is the contents
of smallest None?

273
00:14:48.220 --> 00:14:54.180
If smallest is None, is is like it's
more powerful than double equal sign.

274
00:14:56.040 --> 00:14:59.250
Means is it exactly the same as.

275
00:14:59.250 --> 00:15:02.990
And so if we are asking is smallest None,

276
00:15:02.990 --> 00:15:04.850
that's only true if we've
got a None in there.

277
00:15:04.850 --> 00:15:09.150
If we put 17 in, smallest is not None.

278
00:15:09.150 --> 00:15:10.590
So this is how it works.

279
00:15:10.590 --> 00:15:11.820
Start with smallest equals None.

280
00:15:12.940 --> 00:15:15.310
And then in the code we have
a little bit more intelligence.

281
00:15:16.950 --> 00:15:20.620
If smallest is None,
this means that it's the first time.

282
00:15:22.708 --> 00:15:25.730
If the smallest is None,
smallest is value.

283
00:15:25.730 --> 00:15:27.210
So 9 is coming in here.

284
00:15:29.860 --> 00:15:32.430
And so, if the smallest that we've seen so
far is empty,

285
00:15:32.430 --> 00:15:35.880
we have seen nothing, then we'll grab
the first one as the smallest one.

286
00:15:35.880 --> 00:15:38.293
So our 9 becomes the smallest one.

287
00:15:38.293 --> 00:15:42.990
And so that's how we print out the
smallest so far is 9 and we just saw 9.

288
00:15:42.990 --> 00:15:44.850
Then we come up.

289
00:15:44.850 --> 00:15:51.100
The second time through this loop, this
is going to always be false from now on,

290
00:15:51.100 --> 00:15:54.450
because smallest is a number and
number is not None.

291
00:15:54.450 --> 00:15:57.060
Okay, so we have this flag
value that's None just for

292
00:15:57.060 --> 00:15:58.800
the first time through the loop.

293
00:15:58.800 --> 00:15:59.690
So that's false,

294
00:15:59.690 --> 00:16:04.580
so it's going to run here, elif value
is less than the smallest, which is 41.

295
00:16:04.580 --> 00:16:06.650
Is 41 less than 9 in this case?

296
00:16:06.650 --> 00:16:08.976
And the answer is no, it is not.

297
00:16:08.976 --> 00:16:13.280
So, it stays 9, then 12, 3 works.

298
00:16:13.280 --> 00:16:16.670
So 3 causes this code to run,
so we grab it.

299
00:16:16.670 --> 00:16:19.633
So 3 is it and we go through 74 and 15.

300
00:16:19.633 --> 00:16:21.530
It runs two more times.

301
00:16:21.530 --> 00:16:24.660
And then, when we're all done, we get 3.

302
00:16:24.660 --> 00:16:26.567
This is a flag value

303
00:16:29.931 --> 00:16:34.596
that we're checking and through the loop
it will only be smaller, smallest will only be

304
00:16:34.596 --> 00:16:39.140
None the first time through the loop but after
that we'll just ignore this little part.

305
00:16:39.140 --> 00:16:42.130
This is another way to think
about this is this is priming us.

306
00:16:43.400 --> 00:16:44.234
This is getting started.

307
00:16:48.842 --> 00:16:49.600
Okay?

308
00:16:49.600 --> 00:16:53.180
And this technique is a good way to
do the largest and the smallest.

309
00:16:53.180 --> 00:16:56.950
To use this None and then have a little
bit of code that triggers the first time

310
00:16:56.950 --> 00:17:00.330
through the loop to get your sort
of loop-carried variable setup.

311
00:17:01.470 --> 00:17:05.440
Okay, so the is and is not operator,
they're both operators.

312
00:17:05.440 --> 00:17:09.990
Is and is not are like less than or
less than or equal to or not equal to.

313
00:17:09.990 --> 00:17:14.420
They don't hurt their operands and
they return you a true or a false.

314
00:17:14.420 --> 00:17:18.980
Okay? So is, None, 
and is not is also a logical operator.

315
00:17:18.980 --> 00:17:20.217
And there are other times we use it.

316
00:17:20.217 --> 00:17:24.898
You shouldn't use is when you
should be using double equals,

317
00:17:24.898 --> 00:17:29.950
usually you're using them for
a True, False, or None.

318
00:17:29.950 --> 00:17:35.890
So that we don't overuse is, because is,
is a really, really strong equality.

319
00:17:35.890 --> 00:17:38.260
So it's a stronger equality
than double equals to,

320
00:17:38.260 --> 00:17:43.650
so the double equals is mathematically
equal to with potential conversion.

321
00:17:44.830 --> 00:17:49.190
But is is a stronger thing, and
is not is the opposite of is.

322
00:17:51.340 --> 00:17:55.080
Okay, so in this chapter,
we've talked about some definite loops,

323
00:17:55.080 --> 00:17:56.545
some indefinite loops.

324
00:17:56.545 --> 00:17:58.915
break to get out of loops,
continue to pop back up.

325
00:17:58.915 --> 00:18:01.845
continue works in for
loops as well as while loops.

326
00:18:01.845 --> 00:18:06.705
Iteration variables, how with while loops
you construct them yourself and in for

327
00:18:06.705 --> 00:18:09.535
loops, for constructs them for you.

328
00:18:09.535 --> 00:18:12.463
And things like largest, smallest,
counting, average,

329
00:18:12.463 --> 00:18:13.805
etc., etc., etc.

330
00:18:13.805 --> 00:18:16.395
So we looked at some loop idioms where
you do something at the beginning,

331
00:18:16.395 --> 00:18:19.745
do something in the middle, and
then you get the payoff at the end.